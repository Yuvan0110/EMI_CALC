package com.example.emi_calc

import android.annotation.SuppressLint
import android.app.DatePickerDialog
import android.widget.DatePicker
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.ExpandLess
import androidx.compose.material.icons.filled.ExpandMore
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.example.emi_calc.view_model.InputViewModel
import java.util.Calendar
import java.util.Locale
import java.text.SimpleDateFormat

@OptIn(ExperimentalMaterial3Api::class)
@SuppressLint("UnusedBoxWithConstraintsScope")
@Composable
fun AmortizationExpandableTableSplit(
    viewModel: InputViewModel,
    navController: NavController,
    modifier: Modifier
) {
    val context = LocalContext.current

    // Get initial date in millis from ViewModel
    var selectedDateMillis by remember { mutableStateOf(viewModel.startDateTenure) }

    // Format date string
    val formatter = remember {
        SimpleDateFormat("MMM dd, yyyy", Locale.getDefault())
    }
    val selectedDateStr = formatter.format(selectedDateMillis)

    // Show DatePickerDialog on button click
    val calendar = Calendar.getInstance().apply {
        timeInMillis = selectedDateMillis
    }

    val datePickerDialog = remember {
        DatePickerDialog(
            context,
            { _: DatePicker, year: Int, month: Int, dayOfMonth: Int ->
                calendar.set(year, month, dayOfMonth)
                selectedDateMillis = calendar.timeInMillis
                // Update ViewModel start date
                viewModel.setStartDate(selectedDateMillis)
            },
            calendar.get(Calendar.YEAR),
            calendar.get(Calendar.MONTH),
            calendar.get(Calendar.DAY_OF_MONTH)
        )
    }

    val yearlyData = viewModel.loadYearlyTable()
    val monthlyDataGrouped = viewModel.monthlyBreakdownGroupedByYear()
    val expandedYears = remember { mutableStateMapOf<String, Boolean>() }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Amortization Table") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
                // You can keep colors or remove if you want
            )
        }
    ) { paddingValues ->
        Box(
            modifier = modifier
                .padding(paddingValues)
                .fillMaxSize()
        ) {
            Column(
                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)
            ) {
                // Date picker button & display
                DatePickerOutlinedTextField(
                    dateText = selectedDateStr,
                    onClick = { datePickerDialog.show() },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 12.dp)
                )


                BoxWithConstraints {
                    val minColWidth = 120.dp
                    val dynamicColWidth = if (maxWidth / 5 < minColWidth) minColWidth else maxWidth / 5

                    Row(
                        modifier = Modifier
                            .horizontalScroll(rememberScrollState())
                    ) {
                        Column {
                            Row {
                                TableCell("Year", dynamicColWidth, 56.dp)
                                TableCell("Principal", dynamicColWidth, 56.dp)
                                TableCell("Interest", dynamicColWidth, 56.dp)
                                TableCell("Total Amount\n(Principal + Interest)", dynamicColWidth + 50.dp, 56.dp)
                                TableCell("Balance", dynamicColWidth, 56.dp)
                                TableCell("Loan %", dynamicColWidth, 56.dp)
                            }
                            LazyColumn(
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                items(yearlyData) { yearEntry ->
                                    val year = yearEntry.month
                                    val isExpanded = expandedYears[year] ?: false

                                    Column(modifier = Modifier.fillMaxWidth()) {
                                        Row(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .clickable {
                                                    expandedYears[year] = !isExpanded
                                                }
                                        ) {
                                            Box(
                                                modifier = Modifier
                                                    .width(dynamicColWidth)
                                                    .height(40.dp)
                                                    .border(1.dp, Color.Gray),
                                                contentAlignment = Alignment.Center
                                            ){
                                                Row(
                                                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                                                ){
                                                    Icon(
                                                        imageVector = if(isExpanded)Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                                                        contentDescription = "expand"
                                                    )
                                                    Text(text = yearEntry.month,
                                                        fontSize = 14.sp,
                                                        textAlign = TextAlign.Center
                                                    )
                                                }
                                            }
                                            TableCell("%.2f".format(yearEntry.principalComponent), dynamicColWidth)
                                            TableCell("%.2f".format(yearEntry.interestComponent), dynamicColWidth)
                                            TableCell("%.2f".format(yearEntry.totalAmount), dynamicColWidth + 50.dp)
                                            TableCell("%.2f".format(yearEntry.balance), dynamicColWidth)
                                            TableCell("%.2f".format(yearEntry.loanPercentPaid), dynamicColWidth)
                                        }
                                        if (isExpanded) {
                                            monthlyDataGrouped[year]?.forEach { monthEntry ->
                                                Row(modifier = Modifier.fillMaxWidth()) {
                                                    TableCell(monthEntry.month, dynamicColWidth)
                                                    TableCell("%.2f".format(monthEntry.principalComponent), dynamicColWidth)
                                                    TableCell("%.2f".format(monthEntry.interestComponent), dynamicColWidth)
                                                    TableCell("%.2f".format(monthEntry.totalAmount), dynamicColWidth + 50.dp)
                                                    TableCell("%.2f".format(monthEntry.balance), dynamicColWidth)
                                                    TableCell("%.2f".format(monthEntry.loanPercentPaid), dynamicColWidth)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable fun TableCell(
    text: String,
    width: Dp,
    height : Dp = 40.dp
) {
    Box(
        modifier = Modifier
            .width(width)
            .height(height)
            .border(1.dp, Color.Gray),
        contentAlignment = Alignment.Center )
    {
        Text(
            text = text,
            fontSize = 14.sp,
            textAlign = TextAlign.Center
        )
    }
}


@Composable
fun DatePickerOutlinedTextField(
    dateText: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = dateText,
        onValueChange = {},
        readOnly = true,
        modifier = modifier.clickable { onClick() },
        label = { Text("Start Date") },
        trailingIcon = {
            Icon(
                imageVector = Icons.Default.CalendarToday,
                contentDescription = "Select date",
                tint = MaterialTheme.colorScheme.primary
            )
        },
        enabled = false // disables typing but allows click on whole field via modifier.clickable
    )
}
//table split
//

//
package com.example.emi_calc.view_model

import android.os.Build
import androidx.annotation.RequiresApi
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableLongStateOf
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import com.example.emi_calc.data.EmiBreakdown
import com.example.emi_calc.data.InputState
import com.example.emi_calc.data.TenureUnit
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import kotlin.math.pow

class InputViewModel : ViewModel() {

    private val _input = mutableStateOf(InputState())
    val inputState: InputState get() = _input.value

    private val _table = mutableStateListOf<EmiBreakdown>()
    val table: List<EmiBreakdown> get() = _table

    private val _yearlyTable = mutableStateListOf<EmiBreakdown>()
    val yearlyTable: List<EmiBreakdown> get() = _yearlyTable

    var startDateTenure by mutableLongStateOf(System.currentTimeMillis())

    fun setStartDate(stDate: Long) {
        startDateTenure = stDate
        refreshTables()
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun getStartDateLocalDate(): LocalDate {
        return Instant.ofEpochMilli(startDateTenure)
            .atZone(ZoneId.systemDefault())
            .toLocalDate()
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun refreshTables() {
        loadTable()
        loadYearlyTable()
    }

    fun setPrincipalAmount(value: String) {
        _input.value = _input.value.copy(principal = value)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun setInterestRate(value: String) {
        _input.value = _input.value.copy(interest = value)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun setTenure(value: String) {
        _input.value = _input.value.copy(tenure = value)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun setTenureUnit(unit: TenureUnit) {
        _input.value = _input.value.copy(tenureUnit = unit)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun calcEmi(): Double {
        val r = inputState.interest.toDoubleOrNull()?.div(12)?.div(100) ?: 0.0
        val p = inputState.principal.toDoubleOrNull() ?: 0.0
        val t = inputState.tenure.toIntOrNull() ?: 0

        val n = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> t * 12
            TenureUnit.MONTHS -> t
        }

        if (r == 0.0 || n == 0 || p == 0.0) return 0.0

        val num = (1 + r).pow(n)
        return (p * r * num) / (num - 1)
    }

    fun calcTotalInterest(emi: Double): Double {
        val t = inputState.tenure.toIntOrNull() ?: 0
        val n = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> t * 12
            TenureUnit.MONTHS -> t
        }
        val totalPaid = emi * n
        val principal = inputState.principal.toDoubleOrNull() ?: 0.0
        return totalPaid - principal
    }

    fun calcTotalAmountPayable(emi: Double): Double {
        val t = inputState.tenure.toIntOrNull() ?: 0
        val n = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> t * 12
            TenureUnit.MONTHS -> t
        }
        return emi * n
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun loadTable(): MutableList<EmiBreakdown> {
        _table.clear()
        val principal = inputState.principal.toDoubleOrNull() ?: return _table
        val interest = inputState.interest.toDoubleOrNull() ?: return _table
        val tenure = inputState.tenure.toIntOrNull() ?: return _table
        return calcAmortisationTable(principal, interest, tenure, getStartDateLocalDate())
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun loadYearlyTable(): MutableList<EmiBreakdown> {
        _yearlyTable.clear()
        val principal = inputState.principal.toDoubleOrNull() ?: return _yearlyTable
        val interest = inputState.interest.toDoubleOrNull() ?: return _yearlyTable
        val tenure = inputState.tenure.toIntOrNull() ?: return _yearlyTable
        return calcAmortisationTableYearly(principal, interest, tenure, getStartDateLocalDate())
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun calcAmortisationTable(
        loanAmount: Double,
        annualInterest: Double,
        tenure: Int,
        startDate: LocalDate
    ): MutableList<EmiBreakdown> {
        val monthlyInterest = annualInterest / 12 / 100
        val months = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> tenure * 12
            TenureUnit.MONTHS -> tenure
        }

        // Calculate EMI using formula
        val emi = loanAmount * monthlyInterest * (1 + monthlyInterest).pow(months) / ((1 + monthlyInterest).pow(months) - 1)

        var balance = loanAmount
        var loanPercentPaid = 0.0

        for (month in 0 until months) {
            val interestComponent = balance * monthlyInterest
            val principalComponent = emi - interestComponent
            balance -= principalComponent
            if (balance < 0) balance = 0.0
            loanPercentPaid += principalComponent / loanAmount * 100

            val currentDate = startDate.plusMonths(month.toLong())
            val formattedDate = currentDate.format(java.time.format.DateTimeFormatter.ofPattern("MMM yyyy"))

            _table.add(
                EmiBreakdown(
                    month = formattedDate,
                    principalComponent = principalComponent,
                    interestComponent = interestComponent,
                    totalAmount = emi,
                    balance = balance,
                    loanPercentPaid = loanPercentPaid
                )
            )
        }
        return _table
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun calcAmortisationTableYearly(
        loanAmount: Double,
        annualInterest: Double,
        tenure: Int,
        startDate: LocalDate
    ): MutableList<EmiBreakdown> {
        val monthlyInterest = annualInterest / 12 / 100
        val months = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> tenure * 12
            TenureUnit.MONTHS -> tenure
        }

        val emi = loanAmount * monthlyInterest * (1 + monthlyInterest).pow(months) / ((1 + monthlyInterest).pow(months) - 1)

        var balance = loanAmount
        var loanPercentPaid = 0.0

        var cummPrincipal = 0.0
        var cummInterest = 0.0
        var currentYear = startDate.year

        for (month in 0 until months) {
            val interestComponent = balance * monthlyInterest
            val principalComponent = emi - interestComponent

            val currentDate = startDate.plusMonths(month.toLong())

            // When year changes or last month, add yearly summary
            if (currentDate.year != currentYear) {
                // Add previous year summary
                _yearlyTable.add(
                    EmiBreakdown(
                        month = currentYear.toString(),
                        principalComponent = cummPrincipal,
                        interestComponent = cummInterest,
                        totalAmount = cummPrincipal + cummInterest,
                        balance = balance,
                        loanPercentPaid = loanPercentPaid
                    )
                )
                cummPrincipal = 0.0
                cummInterest = 0.0
                currentYear = currentDate.year
            }

            cummPrincipal += principalComponent
            cummInterest += interestComponent
            balance -= principalComponent
            if (balance < 0) balance = 0.0
            loanPercentPaid += principalComponent / loanAmount * 100
        }

        // Add final year summary
        _yearlyTable.add(
            EmiBreakdown(
                month = currentYear.toString(),
                principalComponent = cummPrincipal,
                interestComponent = cummInterest,
                totalAmount = cummPrincipal + cummInterest,
                balance = balance,
                loanPercentPaid = loanPercentPaid
            )
        )

        return _yearlyTable
    }

    fun monthlyBreakdownGroupedByYear(): Map<String, List<EmiBreakdown>> {
        if (_table.isEmpty()) {
            loadTable()
        }
        return _table.groupBy { it.month.takeLast(4) }
    }
}

// view model
//



import android.graphics.Color
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CurrencyRupee
import androidx.compose.material.icons.filled.Percent
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.text.isDigitsOnly
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.emi_calc.data.TenureUnit
import com.example.emi_calc.view_model.InputViewModel
import com.github.mikephil.charting.charts.PieChart
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.data.PieEntry
import com.github.mikephil.charting.formatter.PercentFormatter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LoanInput(
    viewModel: InputViewModel = viewModel(),
    navController: NavController,
    modifier: Modifier = Modifier
) {
    val input = viewModel.inputState
    var expanded by remember { mutableStateOf(false) }
    var isExpanded by remember { mutableStateOf(false) }
    val tenureUnits = listOf("Years", "Months")


    LaunchedEffect(Unit) {
        if (input.principal.isEmpty()) viewModel.setPrincipalAmount("1000000")
        if (input.interest.isEmpty()) viewModel.setInterestRate("7.5")
        if (input.tenure.isEmpty()) viewModel.setTenure("5")
    }

    val selectedUnit = when (input.tenureUnit) {
        TenureUnit.YEARS -> "Years"
        TenureUnit.MONTHS -> "Months"
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("EMI CALCULATOR")},
                colors = TopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.onPrimaryContainer,
                    navigationIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primaryContainer,
                    actionIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    scrolledContainerColor = MaterialTheme.colorScheme.onPrimaryContainer
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .padding(paddingValues)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp),
            horizontalAlignment = Alignment.Start
        ) {
            OutlinedTextField(
                value = input.principal,
                onValueChange = {
                    if (it.isDigitsOnly() && it.length <= 10) {
                        viewModel.setPrincipalAmount(it)
                    }
                },
                label = { Text("Principal") },
                placeholder = { Text("Enter loan amount") },
                trailingIcon = {
                    Icon(Icons.Default.CurrencyRupee, contentDescription = "Rupee")
                },
                modifier = Modifier.fillMaxWidth()
            )

            OutlinedTextField(
                value = input.interest,
                onValueChange = {
                    val num = it.toDoubleOrNull() ?: 0.0
                    if (num in 0.0..100.0) {
                        if (it.matches(Regex("(^\\d+)?(\\.\\d*)?$"))) {
                            viewModel.setInterestRate(it)
                        }
                    }
                },
                label = { Text("Interest rate") },
                placeholder = { Text("Enter interest rate") },
                trailingIcon = {
                    Icon(Icons.Default.Percent, contentDescription = "Percent")
                },
                modifier = Modifier.fillMaxWidth()
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                OutlinedTextField(
                    value = input.tenure,
                    onValueChange = {
                        if (it.isDigitsOnly() && it.length <= 4) {
                            viewModel.setTenure(it)
                        }
                    },
                    label = { Text("Tenure") },
                    placeholder = { Text("Enter loan tenure") },
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(16.dp))

                ExposedDropdownMenuBox(
                    expanded = isExpanded,
                    onExpandedChange = { isExpanded = !isExpanded },
                    modifier = Modifier.weight(1f)
                ) {
                    OutlinedTextField(
                        readOnly = true,
                        value = selectedUnit,
                        onValueChange = {},
                        label = { Text("Tenure Unit") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isExpanded) },
                        colors = ExposedDropdownMenuDefaults.textFieldColors(),
                        modifier = Modifier.menuAnchor()
                    )

                    DropdownMenu(
                        expanded = isExpanded,
                        onDismissRequest = { isExpanded = false }
                    ) {
                        tenureUnits.forEach { selection ->
                            DropdownMenuItem(
                                text = { Text(selection) },
                                onClick = {
                                    isExpanded = false
                                    viewModel.setTenureUnit(
                                        if (selection == "Years") TenureUnit.YEARS else TenureUnit.MONTHS
                                    )
                                }
                            )
                        }
                    }
                }
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Button(
                    onClick = { navController.navigate("table") },
                    enabled = input.principal.isNotEmpty() &&
                            input.interest.isNotEmpty() &&
                            input.tenure.isNotEmpty()
                ) {
                    Text("View")
                }
            }

            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { expanded = !expanded }
                    .padding(top = 12.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text("Loan Summary")
                    if (expanded) {
                        Spacer(modifier = Modifier.height(12.dp))
                        LoanSummary(viewModel)
                    }
                }
            }

            PieChartSummary(viewModel)
        }
    }
}


@Composable
fun LoanSummary(
    viewModel: InputViewModel,
    modifier: Modifier = Modifier
) {
    val emi = viewModel.calcEmi()
    val interest = viewModel.calcTotalInterest(emi)
    val total = viewModel.calcTotalAmountPayable(emi)

    Column(
        modifier = modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(12.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
        ) {
            Column(Modifier.padding(16.dp)) {
                Text("Monthly EMI:")
                Spacer(Modifier.height(4.dp))
                Text("₹ %.2f".format(emi))
            }
        }

        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
        ) {
            Column(Modifier.padding(16.dp)) {
                Text("Total Interest:")
                Spacer(Modifier.height(4.dp))
                Text("₹ %.2f".format(interest))
            }
        }

        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
        ) {
            Column(Modifier.padding(16.dp)) {
                Text("Total Amount\n(Principal + Interest):")
                Spacer(Modifier.height(4.dp))
                Text("₹ %.2f".format(total))
            }
        }
    }
}

@Composable
fun PieChartSummary(viewModel: InputViewModel = viewModel()) {
    val emi = viewModel.calcEmi()
    val interest = viewModel.calcTotalInterest(emi)
    val principal = viewModel.inputState.principal.toDoubleOrNull() ?: 0.0


    val entries = listOf(
        PieEntry(interest.toFloat(), "Interest"),
        PieEntry(principal.toFloat(), "Principal")
    )

    AndroidView(
        modifier = Modifier
            .fillMaxWidth()
            .height(300.dp),
        factory = { context ->
            PieChart(context)
        },
        update = { chart ->
            val dataSet = PieDataSet(entries, "").apply {
                colors = listOf(
                    Color.parseColor("#8BC34A"),
                    Color.parseColor("#36A2EB")
                )
                valueTextSize = 14f
                valueTextColor = Color.WHITE
                sliceSpace = 2f
            }

            val pieData = PieData(dataSet).apply {
                setValueFormatter(PercentFormatter(chart))
            }

            chart.data = pieData
            chart.setUsePercentValues(true)
            chart.description.isEnabled = false
            chart.isDrawHoleEnabled = true
            chart.setHoleColor(Color.TRANSPARENT)
            chart.setEntryLabelColor(Color.BLACK)
            chart.setEntryLabelTextSize(12f)
            chart.centerText = "Loan Breakdown"
            chart.setCenterTextSize(16f)
            chart.legend.isEnabled = true
            chart.animateXY(1000, 1000)
            chart.invalidate()
        }
    )
}

// input screen
//
