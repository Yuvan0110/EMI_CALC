// LineGraph.kt

package com.example.emi_calc

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarColors
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.emi_calc.view_model.InputViewModel
import com.github.mikephil.charting.charts.LineChart
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LineChartCompose(
    modifier: Modifier = Modifier,
    navController : NavController,
    viewModel: InputViewModel = viewModel(),
) {

    val yearlyData = viewModel.loadYearlyTable()


    val year = yearlyData.map { it.month.takeLast(4).toFloat() }

    // year - balance
    val balance = yearlyData.map { it.balance.toFloat() }
    val entriesYearBalance = year.zip(balance) { year, balance -> Entry(year, balance) }

    // year - principal
    val principal = yearlyData.map { it.principalComponent.toFloat() }
    val entriesYearPrincipal = year.zip(principal) { year, principal -> Entry(year, principal) }

    // year - interest
    val interest = yearlyData.map { it.interestComponent.toFloat() }
    val entriesYearInterest = year.zip(interest) { year, interest -> Entry(year, interest) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Amortization Table") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                colors = TopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.onPrimaryContainer,
                    navigationIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primaryContainer,
                    actionIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    scrolledContainerColor = MaterialTheme.colorScheme.onPrimaryContainer
                )
            )
        }
    ){ padding ->
        Column(
            Modifier
                .fillMaxSize()
        ) {
            AndroidView(
                modifier = modifier
                    .padding(padding)
                    .fillMaxWidth()
                    .height(300.dp),
                factory = { context ->
                    val chart = LineChart(context)

                    val dataSetYearBalance = LineDataSet(entriesYearBalance, "Yearly Balance").apply {
                        color = Color.Cyan.toArgb()
                        setDrawValues(true)
                        lineWidth = 2f
                        setDrawCircles(true)
                    }

                    val dataSetYearPrincipal = LineDataSet(entriesYearPrincipal, "Yearly Principal").apply {
                        color = Color.Green.toArgb()
                        setDrawValues(true)
                        lineWidth = 2f
                        setDrawCircles(true)
                    }

                    val dataSetYearInterest = LineDataSet(entriesYearInterest, "Yearly Interest").apply {
                        color = Color.Yellow.toArgb()
                        setDrawValues(true)
                        lineWidth = 2f
                        setDrawCircles(true)
                    }

                    chart.data = LineData(dataSetYearBalance, dataSetYearPrincipal, dataSetYearInterest)

                    // x axis
                    chart.xAxis.apply {
                        granularity = 1f
                        position = XAxis.XAxisPosition.BOTTOM
                    }

                    // y axis
                    chart.axisLeft.apply {
//                        granularity = 1f
                        axisMinimum = 0f
                    }

                    chart.axisRight.isEnabled = false
                    chart.description.isEnabled = false
                    chart.legend.isEnabled = true

                    // animation
                    chart.animateXY(1000, 1000)

                    chart.invalidate()
                    chart
                }
            )
        }
    }
}











// Loan Input.kt
import android.graphics.Color
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CurrencyRupee
import androidx.compose.material.icons.filled.Percent
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.AbsoluteAlignment
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.text.isDigitsOnly
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.emi_calc.data.TenureUnit
import com.example.emi_calc.view_model.InputViewModel
import com.github.mikephil.charting.charts.PieChart
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.data.PieEntry
import com.github.mikephil.charting.formatter.PercentFormatter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LoanInput(
    modifier: Modifier = Modifier,
    viewModel: InputViewModel = viewModel(),
    navController: NavController
) {
    val input = viewModel.inputState
    var isExpanded by remember { mutableStateOf(false) }
    val tenureUnits = listOf("Years", "Months")


    LaunchedEffect(Unit) {
        if (input.principal.isEmpty()) viewModel.setPrincipalAmount("1000000")
        if (input.interest.isEmpty()) viewModel.setInterestRate("7.5")
        if (input.tenure.isEmpty()) viewModel.setTenure("5")
    }

    val selectedUnit = when (input.tenureUnit) {
        TenureUnit.YEARS -> "Years"
        TenureUnit.MONTHS -> "Months"
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("EMI CALCULATOR")},
                colors = TopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.onPrimaryContainer,
                    navigationIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primaryContainer,
                    actionIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    scrolledContainerColor = MaterialTheme.colorScheme.onPrimaryContainer
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .padding(paddingValues)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp),
            horizontalAlignment = Alignment.Start
        ) {
            OutlinedTextField(
                value = input.principal,
                onValueChange = {
                    if (it.isDigitsOnly() && it.length <= 10) {
                        viewModel.setPrincipalAmount(it)
                    }
                },
                label = { Text("Principal") },
                placeholder = { Text("Enter loan amount") },
                trailingIcon = {
                    Icon(Icons.Default.CurrencyRupee, contentDescription = "Rupee")
                },
                modifier = Modifier.fillMaxWidth()
            )

            OutlinedTextField(
                value = input.interest,
                onValueChange = {
                    val num = it.toDoubleOrNull() ?: 0.0
                    if (num in 0.0..100.0) {
                        if (it.matches(Regex("(^\\d+)?(\\.\\d*)?$"))) {
                            viewModel.setInterestRate(it)
                        }
                    }
                },
                label = { Text("Interest rate") },
                placeholder = { Text("Enter interest rate") },
                trailingIcon = {
                    Icon(Icons.Default.Percent, contentDescription = "Percent")
                },
                modifier = Modifier.fillMaxWidth()
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                OutlinedTextField(
                    value = input.tenure,
                    onValueChange = {
                        if (it.isDigitsOnly() && it.length <= 4) {
                            viewModel.setTenure(it)
                        }
                    },
                    label = { Text("Tenure") },
                    placeholder = { Text("Enter loan tenure") },
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(16.dp))

                ExposedDropdownMenuBox(
                    expanded = isExpanded,
                    onExpandedChange = { isExpanded = !isExpanded },
                    modifier = Modifier.weight(1f)
                ) {
                    OutlinedTextField(
                        readOnly = true,
                        value = selectedUnit,
                        onValueChange = {},
                        label = { Text("Tenure Unit") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = isExpanded) },
                        colors = ExposedDropdownMenuDefaults.textFieldColors(),
                        modifier = Modifier.menuAnchor()
                    )

                    DropdownMenu(
                        expanded = isExpanded,
                        onDismissRequest = { isExpanded = false }
                    ) {
                        tenureUnits.forEach { selection ->
                            DropdownMenuItem(
                                text = { Text(selection) },
                                onClick = {
                                    isExpanded = false
                                    viewModel.setTenureUnit(
                                        if (selection == "Years") TenureUnit.YEARS else TenureUnit.MONTHS
                                    )
                                }
                            )
                        }
                    }
                }
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Button(
                    onClick = { navController.navigate("table") },
                    enabled = input.principal.isNotEmpty() &&
                            input.interest.isNotEmpty() &&
                            input.tenure.isNotEmpty()
                ) {
                    Text("Detailed statistics")
                }

                Button(
                    onClick = { navController.navigate("graph") },
                    enabled = input.principal.isNotEmpty() &&
                            input.interest.isNotEmpty() &&
                            input.tenure.isNotEmpty()
                ) {
                    Text("Show Chart")
                }
            }

            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 12.dp),
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        text = "Loan Summary",
                        fontSize = 20.sp,
                        fontWeight = FontWeight.Bold
                    )
                        Spacer(modifier = Modifier.height(12.dp))
                        LoanSummary(viewModel)
                }
            }

            PieChartSummary(viewModel)
        }
    }
}


@Composable
fun LoanSummary(
    viewModel: InputViewModel,
    modifier: Modifier = Modifier
) {
    val emi = viewModel.calcEmi()
    val interest = viewModel.calcTotalInterest(emi)
    val total = viewModel.calcTotalAmountPayable(emi)

    Column(
        modifier = modifier.fillMaxWidth()
    ) {

            Row(
                Modifier.padding(8.dp).fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "Monthly EMI:",
                    fontWeight = FontWeight.Bold
                )
                Text("₹ %.2f".format(emi))
            }



            Row(
                Modifier.padding(8.dp).fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "Total Interest:",
                    fontWeight = FontWeight.Bold
                )
                Text("₹ %.2f".format(interest))
            }



            Row(
                Modifier.padding(8.dp).fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = "Total Amount\n(Principal + Interest):",
                    fontWeight = FontWeight.Bold
                    )
                Text("₹ %.2f".format(total))
            }

    }
}

@Composable
fun PieChartSummary(viewModel: InputViewModel = viewModel()) {
    val emi = viewModel.calcEmi()
    val interest = viewModel.calcTotalInterest(emi)
    val principal = viewModel.inputState.principal.toDoubleOrNull() ?: 0.0


    val entries = listOf(
        PieEntry(interest.toFloat(), "Interest"),
        PieEntry(principal.toFloat(), "Principal")
    )

    AndroidView(
        modifier = Modifier
            .fillMaxWidth()
            .height(300.dp),
        factory = { context ->
            PieChart(context)
        },
        update = { chart ->
            val dataSet = PieDataSet(entries, "").apply {
                colors = listOf(
                    Color.parseColor("#8BC34A"),
                    Color.parseColor("#36A2EB")
                )
                valueTextSize = 14f
                valueTextColor = Color.WHITE
                sliceSpace = 2f
            }

            val pieData = PieData(dataSet).apply {
                setValueFormatter(PercentFormatter(chart))
            }

            chart.data = pieData
            chart.setUsePercentValues(true)
            chart.description.isEnabled = false
            chart.isDrawHoleEnabled = true
            chart.setHoleColor(Color.TRANSPARENT)
            chart.setEntryLabelColor(Color.BLACK)
            chart.setEntryLabelTextSize(12f)
            chart.centerText = "Loan Breakdown"
            chart.setCenterTextSize(16f)
            chart.legend.isEnabled = true
            chart.animateXY(1000, 1000)
            chart.invalidate()
        }
    )
}





// EmiApp.kt
package com.example.emi_calc


import LoanInput
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.example.emi_calc.view_model.InputViewModel

@RequiresApi(Build.VERSION_CODES.O)
@Composable
fun EmiApp() {
    val navController = rememberNavController()
    val viewModel: InputViewModel = viewModel()

    NavHost(
        navController = navController,
        startDestination = "input"
    ) {
        composable("input") {
            LoanInput(
                viewModel = viewModel,
                navController = navController
            )
        }
        composable("table") {
            AmortizationExpandableTableSplit(
                viewModel = viewModel,
                navController = navController,
                modifier = Modifier
            )
        }
        composable("graph") {
            LineChartCompose(
                viewModel = viewModel,
                navController = navController,
                modifier = Modifier
            )
        }
    }
}



// Split table.kt
package com.example.emi_calc

import android.annotation.SuppressLint
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.ExpandLess
import androidx.compose.material.icons.filled.ExpandMore
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarColors
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateMapOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.example.emi_calc.view_model.InputViewModel
import com.github.mikephil.charting.charts.LineChart
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@SuppressLint("UnusedBoxWithConstraintsScope")
@Composable
fun AmortizationExpandableTableSplit(
    viewModel: InputViewModel,
    navController: NavController,
    modifier: Modifier
) {
    val yearlyData = viewModel.loadYearlyTable()
    val monthlyDataGrouped = viewModel.monthlyBreakdownGroupedByYear()
    val expandedYears = remember { mutableStateMapOf<String, Boolean>() }



    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Amortization Table") },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                colors = TopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.onPrimaryContainer,
                    navigationIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primaryContainer,
                    actionIconContentColor = MaterialTheme.colorScheme.primaryContainer,
                    scrolledContainerColor = MaterialTheme.colorScheme.onPrimaryContainer
                )
            )
        }
    ) { paddingValues ->
        Box(
            modifier = modifier
                .padding(paddingValues)
                .fillMaxSize()
        ) {
            Column(
                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)
            ) {
                StartDateField(
                    viewModel,
                    modifier.fillMaxWidth()
                )

                Spacer(modifier.height(16.dp))

                BoxWithConstraints {
                    val minColWidth = 120.dp
                    val dynamicColWidth = if (maxWidth / 5 < minColWidth) minColWidth else maxWidth / 5

                    Row(
                        modifier = Modifier
                            .horizontalScroll(rememberScrollState())
                    ) {
                        Column {
                            Row {
                                TableCell("Year", dynamicColWidth, 56.dp)
                                TableCell("Principal", dynamicColWidth, 56.dp)
                                TableCell("Interest", dynamicColWidth, 56.dp)
                                TableCell("Total Amount\n(Principal + Interest)", dynamicColWidth + 50.dp, 56.dp)
                                TableCell("Balance", dynamicColWidth, 56.dp)
                                TableCell("Loan percentage\n paid", dynamicColWidth, 56.dp)
                            }
                            LazyColumn(
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                items(yearlyData) { yearEntry ->
                                    val year = yearEntry.month
                                    val isExpanded = expandedYears[year] ?: false

                                    Column(modifier = Modifier.fillMaxWidth()) {
                                        Row(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .clickable {
                                                    expandedYears[year] = !isExpanded
                                                }
                                        ) {
                                            Box(
                                                modifier = Modifier
                                                    .width(dynamicColWidth)
                                                    .height(40.dp)
                                                    .border(1.dp, Color.Gray),
                                                contentAlignment = Alignment.Center
                                            ){
                                                Row(
                                                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                                                ){
                                                    Icon(
                                                        imageVector = if(isExpanded)Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                                                        contentDescription = "expand"
                                                    )
                                                    Text(text = yearEntry.month,
                                                        fontSize = 14.sp,
                                                        textAlign = TextAlign.Center
                                                    )
                                                }
                                            }
                                            TableCell("₹ %.2f".format(yearEntry.principalComponent), dynamicColWidth)
                                            TableCell("₹ %.2f".format(yearEntry.interestComponent), dynamicColWidth)
                                            TableCell("₹ %.2f".format(yearEntry.totalAmount), dynamicColWidth + 50.dp)
                                            TableCell("₹ %.2f".format(yearEntry.balance), dynamicColWidth)
                                            TableCell("%.2f".format(yearEntry.loanPercentPaid) + " %", dynamicColWidth)
                                        }
                                        if (isExpanded) {
                                            monthlyDataGrouped[year]?.forEach { monthEntry ->
                                                Row(modifier = Modifier.fillMaxWidth()) {
                                                    TableCell(monthEntry.month, dynamicColWidth)
                                                    TableCell("₹ %.2f".format(monthEntry.principalComponent), dynamicColWidth)
                                                    TableCell("₹ %.2f".format(monthEntry.interestComponent), dynamicColWidth)
                                                    TableCell("₹ %.2f".format(monthEntry.totalAmount), dynamicColWidth + 50.dp)
                                                    TableCell("₹ %.2f".format(monthEntry.balance), dynamicColWidth)
                                                    TableCell("%.2f".format(monthEntry.loanPercentPaid) + " %", dynamicColWidth)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

    }
}

@Composable fun TableCell(
    text: String,
    width: Dp,
    height : Dp = 40.dp
) {
    Box(
        modifier = Modifier
            .width(width)
            .height(height)
            .border(1.dp, Color.Gray),
        contentAlignment = Alignment.Center )
    {
        Text(
            text = text,
            fontSize = 14.sp,
            textAlign = TextAlign.Center
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun StartDateField(
    viewModel: InputViewModel,
    modifier: Modifier
) {
    var showDatePicker by remember { mutableStateOf(false) }
    val selectedDate = remember { mutableStateOf(viewModel.startDateTenure) }
    val datePickerState = rememberDatePickerState(selectedDate.value)
    OutlinedTextField(
        value = convertMillisToDate(selectedDate.value),
        onValueChange = {},
        label = { Text("Start date") },
        trailingIcon = {
            IconButton(
                onClick = { showDatePicker = true }
            ) {
                Icon(
                    imageVector = Icons.Default.DateRange,
                    contentDescription = "Start Date"
                )
            }
        },
        readOnly = true,
        modifier = Modifier.padding(16.dp).fillMaxWidth()
    )
    if(showDatePicker){
        DatePickerDialog(
            onDismissRequest = { showDatePicker = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let{
                            selectedDate.value = it
                            viewModel.setStartDate(it)
                        }
                        showDatePicker = false
                    }
                ) {
                    Text("OK")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = {
                        showDatePicker = false
                    }
                ) {
                    Text("Cancel")
                }
            }
        ){
            DatePicker(state = datePickerState)
        }
    }
}


fun convertMillisToDate(millis: Long): String {
    val formatter = SimpleDateFormat("MM/dd/yyyy", Locale.getDefault())
    return formatter.format(Date(millis))
}



// Input view model.kt
package com.example.emi_calc.view_model

import android.os.Build
import androidx.annotation.RequiresApi
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableLongStateOf
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import com.example.emi_calc.data.EmiBreakdown
import com.example.emi_calc.data.InputState
import com.example.emi_calc.data.TenureUnit
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import kotlin.math.pow

class InputViewModel : ViewModel() {


    private val _input = mutableStateOf(InputState())
    val inputState: InputState get() = _input.value

    private val _table = mutableStateListOf<EmiBreakdown>()
    val table: List<EmiBreakdown> get() = _table

    private val _yearlyTable = mutableStateListOf<EmiBreakdown>()
    val yearlyTable: List<EmiBreakdown> get() = _yearlyTable

    var startDateTenure by mutableLongStateOf(System.currentTimeMillis())

    fun setStartDate(stDate: Long) {
        startDateTenure = stDate
        refreshTables()
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun getStartDateLocalDate(): LocalDate {
        return Instant.ofEpochMilli(startDateTenure)
            .atZone(ZoneId.systemDefault())
            .toLocalDate()
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun refreshTables() {
        loadTable()
        loadYearlyTable()
    }

    fun setPrincipalAmount(value: String) {
        _input.value = _input.value.copy(principal = value)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun setInterestRate(value: String) {
        _input.value = _input.value.copy(interest = value)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun setTenure(value: String) {
        _input.value = _input.value.copy(tenure = value)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun setTenureUnit(unit: TenureUnit) {
        _input.value = _input.value.copy(tenureUnit = unit)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) refreshTables()
    }

    fun calcEmi(): Double {
        val r = inputState.interest.toDoubleOrNull()?.div(12)?.div(100) ?: 0.0
        val p = inputState.principal.toDoubleOrNull() ?: 0.0
        val t = inputState.tenure.toIntOrNull() ?: 0

        val n = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> t * 12
            TenureUnit.MONTHS -> t
        }

        if (r == 0.0 || n == 0 || p == 0.0) return 0.0

        val num = (1 + r).pow(n)
        return (p * r * num) / (num - 1)
    }

    fun calcTotalInterest(emi: Double): Double {
        val t = inputState.tenure.toIntOrNull() ?: 0
        val n = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> t * 12
            TenureUnit.MONTHS -> t
        }
        val totalPaid = emi * n
        val principal = inputState.principal.toDoubleOrNull() ?: 0.0
        return totalPaid - principal
    }

    fun calcTotalAmountPayable(emi: Double): Double {
        val t = inputState.tenure.toIntOrNull() ?: 0
        val n = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> t * 12
            TenureUnit.MONTHS -> t
        }
        return emi * n
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun loadTable(): MutableList<EmiBreakdown> {
        _table.clear()
        val principal = inputState.principal.toDoubleOrNull() ?: return _table
        val interest = inputState.interest.toDoubleOrNull() ?: return _table
        val tenure = inputState.tenure.toIntOrNull() ?: return _table
        return calcAmortisationTable(principal, interest, tenure, getStartDateLocalDate())
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun loadYearlyTable(): MutableList<EmiBreakdown> {
        _yearlyTable.clear()
        val principal = inputState.principal.toDoubleOrNull() ?: return _yearlyTable
        val interest = inputState.interest.toDoubleOrNull() ?: return _yearlyTable
        val tenure = inputState.tenure.toIntOrNull() ?: return _yearlyTable
        return calcAmortisationTableYearly(principal, interest, tenure, getStartDateLocalDate())
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun calcAmortisationTable(
        loanAmount: Double,
        annualInterest: Double,
        tenure: Int,
        startDate: LocalDate
    ): MutableList<EmiBreakdown> {
        val monthlyInterest = annualInterest / 12 / 100
        val months = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> tenure * 12
            TenureUnit.MONTHS -> tenure
        }

        val emi = loanAmount * monthlyInterest * (1 + monthlyInterest).pow(months) / ((1 + monthlyInterest).pow(months) - 1)

        var balance = loanAmount
        var loanPercentPaid = 0.0

        for (month in 0 until months) {
            val interestComponent = balance * monthlyInterest
            val principalComponent = emi - interestComponent
            balance -= principalComponent
            if (balance < 0) balance = 0.0
            loanPercentPaid += principalComponent / loanAmount * 100

            val currentDate = startDate.plusMonths(month.toLong())
            val formattedDate = currentDate.format(java.time.format.DateTimeFormatter.ofPattern("MMM yyyy"))

            _table.add(
                EmiBreakdown(
                    month = formattedDate,
                    principalComponent = principalComponent,
                    interestComponent = interestComponent,
                    totalAmount = emi,
                    balance = balance,
                    loanPercentPaid = loanPercentPaid
                )
            )
        }
        return _table
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun calcAmortisationTableYearly(
        loanAmount: Double,
        annualInterest: Double,
        tenure: Int,
        startDate: LocalDate
    ): MutableList<EmiBreakdown> {
        val monthlyInterest = annualInterest / 12 / 100
        val months = when (inputState.tenureUnit) {
            TenureUnit.YEARS -> tenure * 12
            TenureUnit.MONTHS -> tenure
        }

        val emi = loanAmount * monthlyInterest * (1 + monthlyInterest).pow(months) / ((1 + monthlyInterest).pow(months) - 1)

        var balance = loanAmount
        var loanPercentPaid = 0.0

        var cummPrincipal = 0.0
        var cummInterest = 0.0
        var currentYear = startDate.year

        for (month in 0 until months) {
            val interestComponent = balance * monthlyInterest
            val principalComponent = emi - interestComponent

            val currentDate = startDate.plusMonths(month.toLong())

            if (currentDate.year != currentYear) {
                _yearlyTable.add(
                    EmiBreakdown(
                        month = currentYear.toString(),
                        principalComponent = cummPrincipal,
                        interestComponent = cummInterest,
                        totalAmount = cummPrincipal + cummInterest,
                        balance = balance,
                        loanPercentPaid = loanPercentPaid
                    )
                )
                cummPrincipal = 0.0
                cummInterest = 0.0
                currentYear = currentDate.year
            }

            cummPrincipal += principalComponent
            cummInterest += interestComponent
            balance -= principalComponent
            if (balance < 0) balance = 0.0
            loanPercentPaid += principalComponent / loanAmount * 100
        }

        _yearlyTable.add(
            EmiBreakdown(
                month = currentYear.toString(),
                principalComponent = cummPrincipal,
                interestComponent = cummInterest,
                totalAmount = cummPrincipal + cummInterest,
                balance = balance,
                loanPercentPaid = loanPercentPaid
            )
        )

        return _yearlyTable
    }

    fun monthlyBreakdownGroupedByYear(): Map<String, List<EmiBreakdown>> {
        if (_table.isEmpty()) {
            loadTable()
        }
        return _table.groupBy { it.month.takeLast(4) }
    }

}
